#!/usr/bin/env bash
set -euo pipefail

# dev-new: Create a new development session with worktree, tmux, and ttyd
# Usage: dev-new <repo> <branch> [--agent opencode|claude]

SCRIPT_PATH="$(readlink -f "$0")"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
DEFAULT_DEV_DIR="$HOME/.dev-sessions"
DEV_DIR="${DEV_DIR:-$DEFAULT_DEV_DIR}"
CONFIG_FILE="$DEV_DIR/config.json"
REPOS_FILE="$DEV_DIR/repos.json"
SESSIONS_DIR="$DEV_DIR/sessions"
CODE_DIR="$HOME/CODE"
WORKTREES_DIR="$CODE_DIR/worktrees"
TEMPLATES_DIR="$DEV_DIR/dev-config/templates"
GITHUB_USER="superficialadam"

# ttyd port range
TTYD_PORT_MIN=7700
TTYD_PORT_MAX=7799

# opencode server port range
OPENCODE_PORT_MIN=4100
OPENCODE_PORT_MAX=4199

# nvim server port range
NVIM_PORT_MIN=6100
NVIM_PORT_MAX=6199

# Source port allocation library
source "$SCRIPT_DIR/lib/ports.sh"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}→${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warn() { echo -e "${YELLOW}!${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1" >&2; }

usage() {
    cat << EOF
Usage: dev-new <repo> <branch> [options]
       dev-new --create <name> [--template <type>] [options]

Create a new development session with worktree, tmux, and AI agent.

Arguments:
  repo      Name of registered repo (see: dev-repo list)
  branch    Branch name (created if doesn't exist)

Options:
  --create <name>    Create a new repo instead of using existing
  --template <type>  Template to use with --create (node, python)
  --agent <n>        Agent to use: opencode, claude (default: from config)
  --no-agent         Don't start an agent
  --no-servers       Don't start dev servers
  --no-ttyd          Don't start ttyd web terminal
  --help             Show this help

Examples:
  dev-new my-app feature/auth
  dev-new my-app fix/bug-123 --agent claude
  dev-new --create my-project --template node
EOF
    exit 0
}

# Find next available port in range
find_available_port() {
    local min=$1
    local max=$2
    for port in $(seq $min $max); do
        if ! ss -tlnp | grep -q ":$port "; then
            echo "$port"
            return
        fi
    done
    echo ""
}

# Generate a deterministic port for a session name (hash-based)
get_session_port() {
    local session_name=$1
    local min=$2
    local max=$3
    local range=$((max - min + 1))
    
    # Use md5sum to generate a hash, take first 8 hex chars, convert to decimal
    local hash=$(echo -n "$session_name" | md5sum | cut -c1-8)
    local hash_dec=$((16#$hash))
    local port=$((min + (hash_dec % range)))
    
    echo "$port"
}

# Parse arguments
REPO=""
BRANCH=""
AGENT=""
CREATE_NEW=false
TEMPLATE=""
START_AGENT=true
START_SERVERS=true
START_TTYD=true

while [[ $# -gt 0 ]]; do
    case $1 in
        --create)
            CREATE_NEW=true
            REPO="$2"
            shift 2
            ;;
        --template)
            TEMPLATE="$2"
            shift 2
            ;;
        --agent)
            AGENT="$2"
            shift 2
            ;;
        --no-agent)
            START_AGENT=false
            shift
            ;;
        --no-servers)
            START_SERVERS=false
            shift
            ;;
        --no-ttyd)
            START_TTYD=false
            shift
            ;;
        --help|-h)
            usage
            ;;
        -*)
            log_error "Unknown option: $1"
            exit 1
            ;;
        *)
            if [[ -z "$REPO" ]]; then
                REPO="$1"
            elif [[ -z "$BRANCH" ]]; then
                BRANCH="$1"
            else
                log_error "Too many arguments"
                exit 1
            fi
            shift
            ;;
    esac
done

if $CREATE_NEW; then
    if [[ -z "$REPO" ]]; then
        log_error "Project name required with --create"
        usage
    fi
    
    PROJECT_NAME="$REPO"
    REPO_PATH="$CODE_DIR/$PROJECT_NAME"
    
    if [[ -d "$REPO_PATH" ]]; then
        log_error "Directory already exists: $REPO_PATH"
        exit 1
    fi
    
    log_info "Creating new project: $PROJECT_NAME"
    mkdir -p "$REPO_PATH"
    
    if [[ -d "$TEMPLATES_DIR/base" ]]; then
        log_info "Applying base template..."
        cp -r "$TEMPLATES_DIR/base/." "$REPO_PATH/"
    fi
    
    if [[ -n "$TEMPLATE" ]]; then
        if [[ ! -d "$TEMPLATES_DIR/$TEMPLATE" ]]; then
            log_error "Template not found: $TEMPLATE"
            log_info "Available templates:"
            ls -1 "$TEMPLATES_DIR" | grep -v base | sed 's/^/  /'
            rm -rf "$REPO_PATH"
            exit 1
        fi
        log_info "Applying $TEMPLATE template..."
        cp -r "$TEMPLATES_DIR/$TEMPLATE/." "$REPO_PATH/"
        
        find "$REPO_PATH" -type f -exec sed -i "s/{{PROJECT_NAME}}/$PROJECT_NAME/g" {} \;
    fi
    
    log_info "Initializing git..."
    git -C "$REPO_PATH" init -b main
    git -C "$REPO_PATH" add -A
    git -C "$REPO_PATH" commit -m "Initial commit from dev-new --create"
    
    log_info "Creating GitHub repo..."
    gh repo create "$GITHUB_USER/$PROJECT_NAME" --private --source="$REPO_PATH" --push
    
    log_info "Adding to repos.json..."
    if [[ ! -f "$REPOS_FILE" ]]; then
        echo '{}' > "$REPOS_FILE"
    fi
    
    jq --arg name "$PROJECT_NAME" \
       --arg url "git@github.com:$GITHUB_USER/$PROJECT_NAME.git" \
       --arg path "$REPO_PATH" \
       '.[$name] = {url: $url, path: $path, default_branch: "main", github: "'"$GITHUB_USER"'/"+$name, dev_servers: []}' \
       "$REPOS_FILE" > "$REPOS_FILE.tmp" && mv "$REPOS_FILE.tmp" "$REPOS_FILE"
    
    log_success "Project created: $PROJECT_NAME"
    
    REPO="$PROJECT_NAME"
    BRANCH="main"
fi

if [[ -z "$REPO" ]] || { ! $CREATE_NEW && [[ -z "$BRANCH" ]]; }; then
    log_error "Missing required arguments"
    usage
fi

if [[ ! -f "$REPOS_FILE" ]]; then
    log_error "Repos file not found: $REPOS_FILE"
    log_info "Run: dev-repo pick"
    exit 1
fi

# Get repo info
REPO_INFO=$(jq -r --arg name "$REPO" '.[$name] // empty' "$REPOS_FILE")
if [[ -z "$REPO_INFO" ]]; then
    log_error "Repo not found: $REPO"
    log_info "Available repos:"
    jq -r 'keys[]' "$REPOS_FILE" | sed 's/^/  /'
    exit 1
fi

REPO_PATH=$(echo "$REPO_INFO" | jq -r '.path')
DEFAULT_BRANCH=$(echo "$REPO_INFO" | jq -r '.default_branch // "main"')
DEV_SERVERS=$(echo "$REPO_INFO" | jq -r '.dev_servers // []')
SETUP_INSTALL=$(echo "$REPO_INFO" | jq -r '.setup.install // []')
REPO_SERVICES=$(echo "$REPO_INFO" | jq -r '.services // []')

if [[ -z "$AGENT" ]]; then
    AGENT=$(jq -r '.default_agent // "opencode"' "$CONFIG_FILE" 2>/dev/null || echo "opencode")
fi

# Generate session name from branch
SESSION_NAME=$(echo "$BRANCH" | tr '/' '-' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')

if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    log_error "Session already exists: $SESSION_NAME"
    log_info "Attach with: dev-attach $SESSION_NAME"
    exit 1
fi

SESSION_DIR="$SESSIONS_DIR/$SESSION_NAME"

if $CREATE_NEW; then
    WORKTREE_PATH="$REPO_PATH"
else
    WORKTREE_PATH="$WORKTREES_DIR/$SESSION_NAME"
    
    if [[ -d "$WORKTREE_PATH" ]]; then
        log_error "Worktree path already exists: $WORKTREE_PATH"
        exit 1
    fi
fi

log_info "Creating session: $SESSION_NAME"
log_info "Repo: $REPO ($REPO_PATH)"
log_info "Branch: $BRANCH"
log_info "Agent: $AGENT"

if ! $CREATE_NEW; then
    log_info "Fetching latest..."
    git -C "$REPO_PATH" fetch --all --prune

    BRANCH_EXISTS=false
    if git -C "$REPO_PATH" show-ref --verify --quiet "refs/heads/$BRANCH" 2>/dev/null; then
        BRANCH_EXISTS=true
    elif git -C "$REPO_PATH" show-ref --verify --quiet "refs/remotes/origin/$BRANCH" 2>/dev/null; then
        BRANCH_EXISTS=true
    fi

    log_info "Creating worktree..."
    mkdir -p "$WORKTREES_DIR"
    if $BRANCH_EXISTS; then
        git -C "$REPO_PATH" worktree add "$WORKTREE_PATH" "$BRANCH"
    else
        log_info "Branch doesn't exist, creating from $DEFAULT_BRANCH..."
        git -C "$REPO_PATH" worktree add -b "$BRANCH" "$WORKTREE_PATH" "origin/$DEFAULT_BRANCH"
    fi
    log_success "Worktree created: $WORKTREE_PATH"

    log_info "Setting up remote tracking..."
    git -C "$WORKTREE_PATH" push -u origin "$BRANCH" 2>/dev/null || {
        git -C "$WORKTREE_PATH" branch --set-upstream-to="origin/$BRANCH" "$BRANCH" 2>/dev/null || true
    }
    log_success "Branch tracking: origin/$BRANCH"
fi

# Run custom install scripts from repo config
INSTALL_COUNT=$(echo "$SETUP_INSTALL" | jq 'length')
if [[ "$INSTALL_COUNT" -gt 0 ]]; then
    log_info "Running $INSTALL_COUNT custom install script(s)..."
    echo "$SETUP_INSTALL" | jq -r '.[]' | while read -r install_cmd; do
        log_info "Running: $install_cmd"
        (cd "$WORKTREE_PATH" && eval "$install_cmd") || {
            log_warn "Install script failed: $install_cmd"
        }
    done
    log_success "Custom install scripts completed"
fi

# Copy .env files from main repository (skip for new projects)
if ! $CREATE_NEW && [[ -d "$REPO_PATH" ]] && [[ "$REPO_PATH" != "$WORKTREE_PATH" ]]; then
    log_info "Syncing .env files from main repository..."
    
    if command -v rsync &> /dev/null; then
        rsync -a --prune-empty-dirs \
            --include='*/' --include='**/.env*' --exclude='*' \
            --exclude='.git/' --exclude='node_modules/' \
            "$REPO_PATH/" "$WORKTREE_PATH/"
        
        count=$(find "$WORKTREE_PATH" -name ".env*" | wc -l)
        if [[ "$count" -gt 0 ]]; then
            log_success "Synced $count .env file(s) from $REPO_PATH"
        else
            log_info "No .env files found in $REPO_PATH"
        fi
    else
        log_warn "rsync not found, falling back to manual copy of root .env"
        if [[ -f "$REPO_PATH/.env" ]]; then
            cp "$REPO_PATH/.env" "$WORKTREE_PATH/.env"
            log_success "Copied root .env"
        fi
    fi
fi

# Create session directory
mkdir -p "$SESSION_DIR"

# Find available ttyd port
TTYD_PORT=""
TTYD_PID=""
if $START_TTYD; then
    TTYD_PORT=$(find_available_port $TTYD_PORT_MIN $TTYD_PORT_MAX)
    if [[ -z "$TTYD_PORT" ]]; then
        log_warn "No available ttyd ports in range $TTYD_PORT_MIN-$TTYD_PORT_MAX"
        START_TTYD=false
    fi
fi

# Get deterministic opencode server port for this session
OPENCODE_PORT=""
if [[ "$AGENT" == "opencode" ]] && $START_AGENT; then
    OPENCODE_PORT=$(get_session_port "$SESSION_NAME" $OPENCODE_PORT_MIN $OPENCODE_PORT_MAX)
    # Check if port is in use, find next available if so
    if ss -tlnp | grep -q ":$OPENCODE_PORT "; then
        log_warn "Preferred opencode port $OPENCODE_PORT in use, finding alternative..."
        OPENCODE_PORT=$(find_available_port $OPENCODE_PORT_MIN $OPENCODE_PORT_MAX)
    fi
    if [[ -z "$OPENCODE_PORT" ]]; then
        log_warn "No available opencode ports in range $OPENCODE_PORT_MIN-$OPENCODE_PORT_MAX"
    fi
fi

# Get deterministic nvim server port for this session
NVIM_PORT=$(get_session_port "${SESSION_NAME}-nvim" $NVIM_PORT_MIN $NVIM_PORT_MAX)
# Check if port is in use, find next available if so
if ss -tlnp | grep -q ":$NVIM_PORT "; then
    log_warn "Preferred nvim port $NVIM_PORT in use, finding alternative..."
    NVIM_PORT=$(find_available_port $NVIM_PORT_MIN $NVIM_PORT_MAX)
fi
if [[ -z "$NVIM_PORT" ]]; then
    log_warn "No available nvim ports in range $NVIM_PORT_MIN-$NVIM_PORT_MAX"
fi

# Create meta.json
cat > "$SESSION_DIR/meta.json" << EOF
{
  "name": "$SESSION_NAME",
  "repo": "$REPO",
  "branch": "$BRANCH",
  "worktree": "$WORKTREE_PATH",
  "agent": "$AGENT",
  "tmux_session": "$SESSION_NAME",
  "ttyd_port": ${TTYD_PORT:-null},
  "opencode_port": ${OPENCODE_PORT:-null},
  "nvim_port": ${NVIM_PORT:-null},
  "created_at": "$(date -Iseconds)",
  "status": "idle",
  "last_activity": "$(date -Iseconds)"
}
EOF
log_success "Session metadata created"

# Create tmux session with servers + nvim windows
log_info "Creating tmux session..."

# Create servers window
tmux new-session -d -s "$SESSION_NAME" -n "servers" -c "$WORKTREE_PATH" bash -c 'eval "$(mise activate bash 2>/dev/null || true)" && exec bash'

# Enable mouse mode for web/mobile terminal access
tmux set-option -t "$SESSION_NAME" mouse on

# Start opencode server in background if requested
if $START_AGENT && [[ "$AGENT" == "opencode" ]] && [[ -n "$OPENCODE_PORT" ]]; then
    tmux send-keys -t "$SESSION_NAME:servers" "cd $WORKTREE_PATH && opencode web --port $OPENCODE_PORT --hostname 0.0.0.0 &" Enter
    log_info "OpenCode server running on port $OPENCODE_PORT"
fi

log_info "Creating pane layout..."
tmux split-window -t "$SESSION_NAME:servers" -h
tmux select-pane -t "$SESSION_NAME:servers.0"
tmux split-window -t "$SESSION_NAME:servers" -v
tmux select-pane -t "$SESSION_NAME:servers.0"
tmux split-window -t "$SESSION_NAME:servers" -v

LEFT_PANE_ORDER=()
while read -r pane_index pane_left pane_top; do
    if [[ "$pane_left" == "0" ]]; then
        LEFT_PANE_ORDER+=("$pane_index:$pane_top")
    fi
done < <(tmux list-panes -t "$SESSION_NAME:servers" -F "#{pane_index} #{pane_left} #{pane_top}")

IFS=$'\n' sorted_left=($(sort -t: -k2,2n <<<"${LEFT_PANE_ORDER[*]}"))
unset IFS
LEFT_PANES=()
for entry in "${sorted_left[@]}"; do
    LEFT_PANES+=("${entry%%:*}")
done

RIGHT_PANE=""
RIGHT_LEFT=-1
while read -r pane_index pane_left; do
    if (( pane_left > RIGHT_LEFT )); then
        RIGHT_LEFT=$pane_left
        RIGHT_PANE=$pane_index
    fi
done < <(tmux list-panes -t "$SESSION_NAME:servers" -F "#{pane_index} #{pane_left}")

if [[ -n "$RIGHT_PANE" && -n "$OPENCODE_PORT" ]]; then
    tmux send-keys -t "$SESSION_NAME:servers.$RIGHT_PANE" "opencode attach http://localhost:$OPENCODE_PORT" Enter
fi

tmux new-window -t "$SESSION_NAME" -n "nvim" -c "$WORKTREE_PATH"
tmux send-keys -t "$SESSION_NAME:nvim" "nvim" Enter

log_success "Tmux session created with servers + nvim windows"

# Start ttyd for this session (supports window switching via URL args)
if $START_TTYD && [[ -n "$TTYD_PORT" ]]; then
    log_info "Starting ttyd on port $TTYD_PORT..."
    
    # Start ttyd with -a flag to allow window selection via URL args
    # URL format: http://host:port/?arg=<window>  (agent|servers|nvim|term)
    nohup ttyd -p "$TTYD_PORT" -i 0.0.0.0 -W -a "$SCRIPT_DIR/ttyd-attach" "$SESSION_NAME" \
        > "$SESSION_DIR/ttyd.log" 2>&1 &
    TTYD_PID=$!
    
    # Store PID
    echo "$TTYD_PID" > "$SESSION_DIR/ttyd.pid"
    
    # Update meta with PID
    jq --arg pid "$TTYD_PID" '.ttyd_pid = ($pid | tonumber)' \
        "$SESSION_DIR/meta.json" > "$SESSION_DIR/meta.json.tmp" \
        && mv "$SESSION_DIR/meta.json.tmp" "$SESSION_DIR/meta.json"
    
    log_success "ttyd started (PID: $TTYD_PID, port: $TTYD_PORT)"
fi



# Start services with port allocation
SERVICES_JSON='{"services":[]}'
REPO_SERVICE_COUNT=$(echo "$REPO_SERVICES" | jq 'length')

if $START_SERVERS && [[ "$REPO_SERVICE_COUNT" -gt 0 ]]; then
    log_info "Starting $REPO_SERVICE_COUNT service(s) with port allocation..."

    PANE_ORDER=("${LEFT_PANES[@]}")
    if [[ ${#PANE_ORDER[@]} -lt 3 ]]; then
        PANE_ORDER=(0 1 2)
    fi
    SERVICE_IDX=0
    
    echo "$REPO_SERVICES" | jq -c '.[]' | while read -r service; do
        if [[ $SERVICE_IDX -ge 3 ]]; then
            log_warn "More than 3 services, only starting first 3"
            break
        fi
        SERVICE_NAME=$(echo "$service" | jq -r '.name')
        SERVICE_CMD=$(echo "$service" | jq -r '.cmd')
        SERVICE_CWD=$(echo "$service" | jq -r '.cwd // ""')
        PORT_ENV=$(echo "$service" | jq -r '.port_env // ""')
        
        ALLOCATED_PORT=""
        if [[ -n "$PORT_ENV" ]]; then
            ALLOCATED_PORT=$(allocate_service_port)
            if [[ -z "$ALLOCATED_PORT" ]]; then
                log_warn "Could not allocate port for service $SERVICE_NAME"
            fi
        fi
        
        PANE_IN_WINDOW=$((SERVICE_IDX % 3))
        PANE=${PANE_ORDER[$PANE_IN_WINDOW]}
        
        PANE_TARGET="$SESSION_NAME:servers.$PANE"
        
        FULL_CWD="$WORKTREE_PATH"
        [[ -n "$SERVICE_CWD" ]] && FULL_CWD="$WORKTREE_PATH/$SERVICE_CWD"
        
        FULL_CMD="cd $FULL_CWD && "
        if [[ -n "$ALLOCATED_PORT" && -n "$PORT_ENV" ]]; then
            FULL_CMD+="$PORT_ENV=$ALLOCATED_PORT "
            log_info "Service $SERVICE_NAME: port $ALLOCATED_PORT"
        fi
        FULL_CMD+="$SERVICE_CMD"
        
        tmux send-keys -t "$PANE_TARGET" "$FULL_CMD" Enter
        
        add_service "$SERVICE_NAME" "${ALLOCATED_PORT:-0}" "$PANE_TARGET" "$SERVICE_CMD" "$SERVICE_CWD"
        
        SERVICE_IDX=$((SERVICE_IDX + 1))
    done
    
    save_services "$SESSION_NAME"
    log_success "Services started and saved to services.json"

elif $START_SERVERS; then
    SERVER_COUNT=$(echo "$DEV_SERVERS" | jq 'length')
    if [[ "$SERVER_COUNT" -gt 0 ]]; then
        log_info "Starting $SERVER_COUNT dev server(s) (legacy config)..."

        PANE_ORDER=("${LEFT_PANES[@]}")
        if [[ ${#PANE_ORDER[@]} -lt 3 ]]; then
            PANE_ORDER=(0 1 2)
        fi
        i=0
        echo "$DEV_SERVERS" | jq -c '.[]' | while read -r server; do
            if [[ $i -ge 3 ]]; then
                log_warn "More than 3 servers, only starting first 3"
                break
            fi
            SERVER_NAME=$(echo "$server" | jq -r '.name')
            SERVER_CMD=$(echo "$server" | jq -r '.cmd')
            PANE=${PANE_ORDER[$i]}

            tmux select-pane -t "$SESSION_NAME:servers.$PANE"
            tmux send-keys -t "$SESSION_NAME:servers" "$SERVER_CMD" Enter
            i=$((i + 1))
        done

        tmux select-layout -t "$SESSION_NAME:servers" tiled
    fi
fi

# Select servers window
tmux select-window -t "$SESSION_NAME:servers"

log_success "Session ready: $SESSION_NAME"
echo ""
echo "Commands:"
echo "  dev-attach $SESSION_NAME          # attach in terminal"
echo "  dev-send $SESSION_NAME \"prompt\"   # send prompt"
echo "  dev-ports $SESSION_NAME           # show service ports"
echo "  dev-logs $SESSION_NAME [service]  # tail service logs"
echo ""
echo "Web interfaces:"
if [[ -n "$TTYD_PORT" ]]; then
echo "  Terminal: http://localhost:$TTYD_PORT"
fi
if [[ -n "$OPENCODE_PORT" ]]; then
echo "  OpenCode: http://localhost:$OPENCODE_PORT"
fi

if [[ -f "$SESSION_DIR/services.json" ]]; then
    echo ""
    echo "Services:"
    jq -r '.services[] | "  \(.name): http://localhost:\(.port)"' "$SESSION_DIR/services.json" 2>/dev/null || true
fi
