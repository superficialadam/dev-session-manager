#!/usr/bin/env bash
set -euo pipefail

# dev-new: Create a new development session with worktree, tmux, and ttyd
# Usage: dev-new <repo> <branch> [--agent opencode|claude]

SCRIPT_PATH="$(readlink -f "$0")"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
DEFAULT_DEV_DIR="$HOME/.dev-sessions"
DEV_DIR="${DEV_DIR:-$DEFAULT_DEV_DIR}"
CONFIG_FILE="$DEV_DIR/config.json"
REPOS_FILE="$DEV_DIR/repos.json"
SESSIONS_DIR="$DEV_DIR/sessions"
CODE_DIR="$HOME/CODE"
WORKTREES_DIR="$CODE_DIR/worktrees"

# ttyd port range
TTYD_PORT_MIN=7700
TTYD_PORT_MAX=7799

# opencode server port range
OPENCODE_PORT_MIN=4100
OPENCODE_PORT_MAX=4199

# nvim server port range
NVIM_PORT_MIN=6100
NVIM_PORT_MAX=6199

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}→${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warn() { echo -e "${YELLOW}!${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1" >&2; }

usage() {
    cat << EOF
Usage: dev-new <repo> <branch> [options]

Create a new development session with worktree, tmux, and AI agent.

Arguments:
  repo      Name of registered repo (see: dev-repo list)
  branch    Branch name (created if doesn't exist)

Options:
  --agent <n>       Agent to use: opencode, claude (default: from config)
  --no-agent           Don't start an agent
  --no-servers         Don't start dev servers
  --no-ttyd            Don't start ttyd web terminal
  --help               Show this help

Examples:
  dev-new my-app feature/auth
  dev-new my-app fix/bug-123 --agent claude
EOF
    exit 0
}

# Find next available port in range
find_available_port() {
    local min=$1
    local max=$2
    for port in $(seq $min $max); do
        if ! ss -tlnp | grep -q ":$port "; then
            echo "$port"
            return
        fi
    done
    echo ""
}

# Generate a deterministic port for a session name (hash-based)
get_session_port() {
    local session_name=$1
    local min=$2
    local max=$3
    local range=$((max - min + 1))
    
    # Use md5sum to generate a hash, take first 8 hex chars, convert to decimal
    local hash=$(echo -n "$session_name" | md5sum | cut -c1-8)
    local hash_dec=$((16#$hash))
    local port=$((min + (hash_dec % range)))
    
    echo "$port"
}

# Parse arguments
REPO=""
BRANCH=""
AGENT=""
START_AGENT=true
START_SERVERS=true
START_TTYD=true

while [[ $# -gt 0 ]]; do
    case $1 in
        --agent)
            AGENT="$2"
            shift 2
            ;;
        --no-agent)
            START_AGENT=false
            shift
            ;;
        --no-servers)
            START_SERVERS=false
            shift
            ;;
        --no-ttyd)
            START_TTYD=false
            shift
            ;;
        --help|-h)
            usage
            ;;
        -*)
            log_error "Unknown option: $1"
            exit 1
            ;;
        *)
            if [[ -z "$REPO" ]]; then
                REPO="$1"
            elif [[ -z "$BRANCH" ]]; then
                BRANCH="$1"
            else
                log_error "Too many arguments"
                exit 1
            fi
            shift
            ;;
    esac
done

if [[ -z "$REPO" || -z "$BRANCH" ]]; then
    log_error "Missing required arguments"
    usage
fi

if [[ ! -f "$REPOS_FILE" ]]; then
    log_error "Repos file not found: $REPOS_FILE"
    log_info "Run: dev-repo pick"
    exit 1
fi

# Get repo info
REPO_INFO=$(jq -r --arg name "$REPO" '.[$name] // empty' "$REPOS_FILE")
if [[ -z "$REPO_INFO" ]]; then
    log_error "Repo not found: $REPO"
    log_info "Available repos:"
    jq -r 'keys[]' "$REPOS_FILE" | sed 's/^/  /'
    exit 1
fi

REPO_PATH=$(echo "$REPO_INFO" | jq -r '.path')
DEFAULT_BRANCH=$(echo "$REPO_INFO" | jq -r '.default_branch // "main"')
DEV_SERVERS=$(echo "$REPO_INFO" | jq -r '.dev_servers // []')

if [[ -z "$AGENT" ]]; then
    AGENT=$(jq -r '.default_agent // "opencode"' "$CONFIG_FILE" 2>/dev/null || echo "opencode")
fi

# Generate session name from branch
SESSION_NAME=$(echo "$BRANCH" | tr '/' '-' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')

if tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    log_error "Session already exists: $SESSION_NAME"
    log_info "Attach with: dev-attach $SESSION_NAME"
    exit 1
fi

WORKTREE_PATH="$WORKTREES_DIR/$SESSION_NAME"
SESSION_DIR="$SESSIONS_DIR/$SESSION_NAME"

if [[ -d "$WORKTREE_PATH" ]]; then
    log_error "Worktree path already exists: $WORKTREE_PATH"
    exit 1
fi

log_info "Creating session: $SESSION_NAME"
log_info "Repo: $REPO ($REPO_PATH)"
log_info "Branch: $BRANCH"
log_info "Agent: $AGENT"

# Fetch latest
log_info "Fetching latest..."
git -C "$REPO_PATH" fetch --all --prune

# Check if branch exists
BRANCH_EXISTS=false
if git -C "$REPO_PATH" show-ref --verify --quiet "refs/heads/$BRANCH" 2>/dev/null; then
    BRANCH_EXISTS=true
elif git -C "$REPO_PATH" show-ref --verify --quiet "refs/remotes/origin/$BRANCH" 2>/dev/null; then
    BRANCH_EXISTS=true
fi

# Create worktree
log_info "Creating worktree..."
mkdir -p "$WORKTREES_DIR"
if $BRANCH_EXISTS; then
    git -C "$REPO_PATH" worktree add "$WORKTREE_PATH" "$BRANCH"
else
    log_info "Branch doesn't exist, creating from $DEFAULT_BRANCH..."
    git -C "$REPO_PATH" worktree add -b "$BRANCH" "$WORKTREE_PATH" "origin/$DEFAULT_BRANCH"
fi
log_success "Worktree created: $WORKTREE_PATH"

# Install dependencies
log_info "Installing dependencies..."
if [[ -f "$WORKTREE_PATH/pnpm-lock.yaml" ]]; then
    pnpm install -C "$WORKTREE_PATH"
elif [[ -f "$WORKTREE_PATH/package-lock.json" ]]; then
    npm install --prefix "$WORKTREE_PATH"
elif [[ -f "$WORKTREE_PATH/yarn.lock" ]]; then
    yarn --cwd "$WORKTREE_PATH" install
elif [[ -f "$WORKTREE_PATH/package.json" ]]; then
    # Default to pnpm if available, else npm
    if command -v pnpm &> /dev/null; then
        pnpm install -C "$WORKTREE_PATH"
    else
        npm install --prefix "$WORKTREE_PATH"
    fi
fi

# Copy .env files from main repository
log_info "Syncing .env files from main repository..."

# REPO_PATH is now the main non-bare repo (e.g. ~/CODE/cos-capture)
if [[ -d "$REPO_PATH" ]]; then
    # Use rsync to copy only .env files, preserving directory structure
    # --include='*/'       : visit all directories
    # --include='**/.env*' : include .env, .env.local, .env.development, etc.
    # --exclude='*'        : exclude everything else
    # --prune-empty-dirs   : don't create empty directories
    
    if command -v rsync &> /dev/null; then
        rsync -a --prune-empty-dirs \
            --include='*/' --include='**/.env*' --exclude='*' \
            --exclude='.git/' --exclude='node_modules/' \
            "$REPO_PATH/" "$WORKTREE_PATH/"
        
        count=$(find "$WORKTREE_PATH" -name ".env*" | wc -l)
        if [[ "$count" -gt 0 ]]; then
            log_success "Synced $count .env file(s) from $REPO_PATH"
        else
            log_info "No .env files found in $REPO_PATH"
        fi
    else
        log_warn "rsync not found, falling back to manual copy of root .env"
        if [[ -f "$REPO_PATH/.env" ]]; then
            cp "$REPO_PATH/.env" "$WORKTREE_PATH/.env"
            log_success "Copied root .env"
        fi
    fi
fi

# Create session directory
mkdir -p "$SESSION_DIR"

# Auto-detect dev servers if none configured
if [[ $(echo "$DEV_SERVERS" | jq 'length') -eq 0 ]] && [[ -f "$WORKTREE_PATH/package.json" ]]; then
    log_info "No servers configured, scanning package.json..."
    
    DETECTED_SERVERS="[]"
    
    # Read scripts from package.json
    SCRIPTS=$(jq -r '.scripts | to_entries[] | "\(.key):\(.value)"' "$WORKTREE_PATH/package.json" 2>/dev/null || echo "")
    
    # Priority list of script names to auto-run
    for script_name in "dev" "start:dev" "develop" "start"; do
        if echo "$SCRIPTS" | grep -q "^$script_name:"; then
            CMD=$(echo "$SCRIPTS" | grep "^$script_name:" | head -1 | cut -d: -f2-)
            log_info "Auto-detected server: $script_name ($CMD)"
            
            # Construct JSON object
            SERVER_OBJ=$(jq -n \
                --arg name "$script_name" \
                --arg cmd "npm run $script_name" \
                '{name: $name, cmd: $cmd}')
            
            DETECTED_SERVERS=$(echo "$DETECTED_SERVERS" | jq --argjson obj "$SERVER_OBJ" '. + [$obj]')
            
            # Only pick the first one we find (usually 'dev' is enough)
            break
        fi
    done
    
    if [[ $(echo "$DETECTED_SERVERS" | jq 'length') -gt 0 ]]; then
        DEV_SERVERS="$DETECTED_SERVERS"
        START_SERVERS=true
    fi
fi

# Find available ttyd port
TTYD_PORT=""
TTYD_PID=""
if $START_TTYD; then
    TTYD_PORT=$(find_available_port $TTYD_PORT_MIN $TTYD_PORT_MAX)
    if [[ -z "$TTYD_PORT" ]]; then
        log_warn "No available ttyd ports in range $TTYD_PORT_MIN-$TTYD_PORT_MAX"
        START_TTYD=false
    fi
fi

# Get deterministic opencode server port for this session
OPENCODE_PORT=""
if [[ "$AGENT" == "opencode" ]] && $START_AGENT; then
    OPENCODE_PORT=$(get_session_port "$SESSION_NAME" $OPENCODE_PORT_MIN $OPENCODE_PORT_MAX)
    # Check if port is in use, find next available if so
    if ss -tlnp | grep -q ":$OPENCODE_PORT "; then
        log_warn "Preferred opencode port $OPENCODE_PORT in use, finding alternative..."
        OPENCODE_PORT=$(find_available_port $OPENCODE_PORT_MIN $OPENCODE_PORT_MAX)
    fi
    if [[ -z "$OPENCODE_PORT" ]]; then
        log_warn "No available opencode ports in range $OPENCODE_PORT_MIN-$OPENCODE_PORT_MAX"
    fi
fi

# Get deterministic nvim server port for this session
NVIM_PORT=$(get_session_port "${SESSION_NAME}-nvim" $NVIM_PORT_MIN $NVIM_PORT_MAX)
# Check if port is in use, find next available if so
if ss -tlnp | grep -q ":$NVIM_PORT "; then
    log_warn "Preferred nvim port $NVIM_PORT in use, finding alternative..."
    NVIM_PORT=$(find_available_port $NVIM_PORT_MIN $NVIM_PORT_MAX)
fi
if [[ -z "$NVIM_PORT" ]]; then
    log_warn "No available nvim ports in range $NVIM_PORT_MIN-$NVIM_PORT_MAX"
fi

# Create meta.json
cat > "$SESSION_DIR/meta.json" << EOF
{
  "name": "$SESSION_NAME",
  "repo": "$REPO",
  "branch": "$BRANCH",
  "worktree": "$WORKTREE_PATH",
  "agent": "$AGENT",
  "tmux_session": "$SESSION_NAME",
  "ttyd_port": ${TTYD_PORT:-null},
  "opencode_port": ${OPENCODE_PORT:-null},
  "nvim_port": ${NVIM_PORT:-null},
  "created_at": "$(date -Iseconds)",
  "status": "idle",
  "last_activity": "$(date -Iseconds)"
}
EOF
log_success "Session metadata created"

# Create tmux session with 1 window (servers) with custom layout
log_info "Creating tmux session..."

# Create servers window
tmux new-session -d -s "$SESSION_NAME" -n "servers" -c "$WORKTREE_PATH" bash -c 'eval "$(mise activate bash 2>/dev/null || true)" && exec bash'

# Enable mouse support
tmux set-option -t "$SESSION_NAME" mouse on

# Start opencode server in background if requested
if $START_AGENT && [[ "$AGENT" == "opencode" ]] && [[ -n "$OPENCODE_PORT" ]]; then
    tmux send-keys -t "$SESSION_NAME:servers" "cd $WORKTREE_PATH && opencode serve --port $OPENCODE_PORT --hostname 0.0.0.0 &" Enter
    log_info "OpenCode server running on port $OPENCODE_PORT"
fi

# Start nvim server in background if port available
if [[ -n "$NVIM_PORT" ]]; then
    tmux send-keys -t "$SESSION_NAME:servers" "nvim --headless --listen 0.0.0.0:$NVIM_PORT &" Enter
    log_info "Neovim server running on port $NVIM_PORT"
fi

# Create pane layout: vertical split, then left horizontally split
tmux split-window -t "$SESSION_NAME:servers" -h  # vertical split: left .0, right .1
tmux select-pane -t "$SESSION_NAME:servers.0"
tmux split-window -t "$SESSION_NAME:servers" -v  # horizontal split left: top .0, bottom .2 (since .1 is right)

# Now panes: .0 (top-left), .2 (bottom-left), .1 (right)

log_success "Tmux session created with servers window and 3-pane layout"

# Start ttyd for this session (supports window switching via URL args)
if $START_TTYD && [[ -n "$TTYD_PORT" ]]; then
    log_info "Starting ttyd on port $TTYD_PORT..."
    
    # Start ttyd with -a flag to allow window selection via URL args
    # URL format: http://host:port/?arg=<window>  (agent|servers|nvim|term)
    nohup ttyd -p "$TTYD_PORT" -i 0.0.0.0 -W -a "$SCRIPT_DIR/ttyd-attach" "$SESSION_NAME" \
        > "$SESSION_DIR/ttyd.log" 2>&1 &
    TTYD_PID=$!
    
    # Store PID
    echo "$TTYD_PID" > "$SESSION_DIR/ttyd.pid"
    
    # Update meta with PID
    jq --arg pid "$TTYD_PID" '.ttyd_pid = ($pid | tonumber)' \
        "$SESSION_DIR/meta.json" > "$SESSION_DIR/meta.json.tmp" \
        && mv "$SESSION_DIR/meta.json.tmp" "$SESSION_DIR/meta.json"
    
    log_success "ttyd started (PID: $TTYD_PID, port: $TTYD_PORT)"
fi



# Start dev servers in the servers window panes
if $START_SERVERS; then
    SERVER_COUNT=$(echo "$DEV_SERVERS" | jq 'length')
    if [[ "$SERVER_COUNT" -gt 0 ]]; then
        log_info "Starting $SERVER_COUNT dev server(s)..."

        # Pane order: top-left (.0), bottom-left (.2), right (.1)
        PANE_ORDER=(0 2 1)
        i=0
        echo "$DEV_SERVERS" | jq -c '.[]' | while read -r server; do
            if [[ $i -ge 3 ]]; then
                log_warn "More than 3 servers, only starting first 3"
                break
            fi
            SERVER_NAME=$(echo "$server" | jq -r '.name')
            SERVER_CMD=$(echo "$server" | jq -r '.cmd')
            PANE=${PANE_ORDER[$i]}

            tmux select-pane -t "$SESSION_NAME:servers.$PANE"
            tmux send-keys -t "$SESSION_NAME:servers" "$SERVER_CMD" Enter
            i=$((i + 1))
        done

        tmux select-layout -t "$SESSION_NAME:servers" tiled
    fi
fi

# Select servers window
tmux select-window -t "$SESSION_NAME:servers"

log_success "Session ready: $SESSION_NAME"
echo ""
echo "Commands:"
echo "  dev-attach $SESSION_NAME          # attach in terminal"
echo "  dev-send $SESSION_NAME \"prompt\"   # send prompt"
echo ""
echo "Web interfaces:"
if [[ -n "$TTYD_PORT" ]]; then
echo "  Terminal: http://localhost:$TTYD_PORT"
fi
if [[ -n "$OPENCODE_PORT" ]]; then
echo "  OpenCode: http://localhost:$OPENCODE_PORT"
fi
if [[ -n "$NVIM_PORT" ]]; then
echo "  Neovim: nvim --remote-ui --server localhost:$NVIM_PORT"
fi
