#!/usr/bin/env bash
set -euo pipefail

SCRIPT_PATH="$(readlink -f "$0")"
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
DEFAULT_DEV_DIR="$HOME/.dev-sessions"
DEV_DIR="${DEV_DIR:-$DEFAULT_DEV_DIR}"
SESSIONS_DIR="$DEV_DIR/sessions"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

usage() {
    cat << EOF
Usage: dev-check [service-name] [options]

Check service status and errors for the current dev session.
Auto-detects session from current working directory.

Arguments:
  service-name    Check specific service (optional, checks all if omitted)

Options:
  -v, --verbose   Show last 30 lines of output
  -n <lines>      Show last N lines of output
  --help          Show this help

Examples:
  dev-check                  # check all services in current session
  dev-check dashboard        # check dashboard service
  dev-check -v               # verbose output for all services
  dev-check dashboard -n 50  # show last 50 lines for dashboard
EOF
    exit 0
}

find_session_from_cwd() {
    local cwd="$PWD"
    
    for session_dir in "$SESSIONS_DIR"/*/; do
        [[ -d "$session_dir" ]] || continue
        local meta_file="$session_dir/meta.json"
        [[ -f "$meta_file" ]] || continue
        
        local worktree
        worktree=$(jq -r '.worktree // empty' "$meta_file" 2>/dev/null)
        
        if [[ -n "$worktree" && "$cwd" == "$worktree"* ]]; then
            basename "$session_dir"
            return 0
        fi
    done
    
    return 1
}

ERROR_PATTERNS=(
    "Error:"
    "ERROR"
    "error:"
    "EADDRINUSE"
    "EACCES"
    "ENOENT"
    "SyntaxError"
    "TypeError"
    "ReferenceError"
    "Cannot find module"
    "Module not found"
    "failed"
    "Failed"
    "FAILED"
    "Exception"
    "Traceback"
    "panic:"
    "fatal:"
    "FATAL"
)

check_for_errors() {
    local output="$1"
    local errors=""
    
    for pattern in "${ERROR_PATTERNS[@]}"; do
        local matches
        matches=$(echo "$output" | grep -i "$pattern" | tail -3)
        if [[ -n "$matches" ]]; then
            errors+="$matches"$'\n'
        fi
    done
    
    echo "$errors"
}

SERVICE_NAME=""
VERBOSE=false
LINES=30

while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -n)
            LINES="$2"
            VERBOSE=true
            shift 2
            ;;
        --help|-h)
            usage
            ;;
        -*)
            echo -e "${RED}✗${NC} Unknown option: $1" >&2
            exit 1
            ;;
        *)
            SERVICE_NAME="$1"
            shift
            ;;
    esac
done

SESSION_NAME=$(find_session_from_cwd) || {
    echo -e "${RED}✗${NC} Not in a dev session directory" >&2
    echo "  Run this from within a worktree managed by dev-session-manager" >&2
    exit 1
}

SESSION_DIR="$SESSIONS_DIR/$SESSION_NAME"
SERVICES_FILE="$SESSION_DIR/services.json"
META_FILE="$SESSION_DIR/meta.json"

echo -e "${BLUE}Session:${NC} $SESSION_NAME"
echo ""

if ! tmux has-session -t "$SESSION_NAME" 2>/dev/null; then
    echo -e "${RED}✗${NC} Tmux session not running"
    echo "  Start with: dev-restart $SESSION_NAME"
    exit 1
fi

check_service() {
    local name="$1"
    local pane="$2"
    local port="$3"
    
    local output
    output=$(tmux capture-pane -t "$pane" -p -S -100 2>/dev/null) || {
        echo -e "${YELLOW}$name${NC} (port $port)"
        echo "  Status: ${YELLOW}pane not found${NC}"
        return
    }
    
    local errors
    errors=$(check_for_errors "$output")
    
    if [[ -n "$errors" ]]; then
        echo -e "${RED}$name${NC} (port $port, pane $pane)"
        echo -e "  Status: ${RED}ERROR${NC}"
        echo "$errors" | head -5 | sed 's/^/  /'
    else
        echo -e "${GREEN}$name${NC} (port $port, pane $pane)"
        echo -e "  Status: ${GREEN}running${NC}"
    fi
    
    if $VERBOSE; then
        echo ""
        echo "  Last $LINES lines:"
        echo "$output" | tail -"$LINES" | sed 's/^/  │ /'
    fi
    
    echo ""
}

if [[ -f "$SERVICES_FILE" ]]; then
    if [[ -n "$SERVICE_NAME" ]]; then
        SERVICE=$(jq -r --arg name "$SERVICE_NAME" '.services[] | select(.name == $name)' "$SERVICES_FILE")
        if [[ -z "$SERVICE" ]]; then
            echo -e "${RED}✗${NC} Service not found: $SERVICE_NAME" >&2
            echo ""
            echo "Available services:"
            jq -r '.services[].name' "$SERVICES_FILE" | sed 's/^/  /'
            exit 1
        fi
        
        PANE=$(echo "$SERVICE" | jq -r '.pane')
        PORT=$(echo "$SERVICE" | jq -r '.port // 0')
        check_service "$SERVICE_NAME" "$PANE" "$PORT"
    else
        jq -c '.services[]' "$SERVICES_FILE" | while read -r service; do
            NAME=$(echo "$service" | jq -r '.name')
            PANE=$(echo "$service" | jq -r '.pane')
            PORT=$(echo "$service" | jq -r '.port // 0')
            check_service "$NAME" "$PANE" "$PORT"
        done
    fi
else
    echo -e "${YELLOW}No services configured${NC}"
    echo ""
    echo "Checking default panes..."
    echo ""
    
    for pane in 0 1 2; do
        PANE_TARGET="$SESSION_NAME:servers.$pane"
        if tmux list-panes -t "$SESSION_NAME:servers" -F "#{pane_index}" 2>/dev/null | grep -q "^$pane$"; then
            output=$(tmux capture-pane -t "$PANE_TARGET" -p -S -50 2>/dev/null) || continue
            errors=$(check_for_errors "$output")
            
            if [[ -n "$errors" ]]; then
                echo -e "${RED}Pane $pane${NC}"
                echo -e "  Status: ${RED}ERROR${NC}"
                echo "$errors" | head -3 | sed 's/^/  /'
            else
                echo -e "${GREEN}Pane $pane${NC}"
                echo -e "  Status: ${GREEN}OK${NC}"
            fi
            
            if $VERBOSE; then
                echo ""
                echo "$output" | tail -"$LINES" | sed 's/^/  │ /'
            fi
            echo ""
        fi
    done
fi
